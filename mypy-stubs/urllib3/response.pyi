import http.client
import io
import typing

import _typeshed
import urllib3._collections
import urllib3.util.retry

_URL = typing.Any
_Connection = typing.Any
_Body = typing.Union[typing.Text, bytes, typing.TextIO, typing.BinaryIO]

class HTTPResponse(io.IOBase):
    CONTENT_DECODERS: typing.List[str] = ...
    REDIRECT_STATUSES: typing.List[int] = ...
    headers: urllib3._collections.HTTPHeaderDict = ...
    status: int = ...
    version: int = ...
    reason: typing.Optional[str] = ...
    strict: int = ...
    decode_content: bool = ...
    retries: typing.Optional[urllib3.util.retry.Retry] = ...
    enforce_content_length: bool = ...
    auto_close: bool = ...
    msg: typing.Any = ...
    chunked: bool = ...
    chunk_left: typing.Optional[int] = ...
    length_remaining: typing.Optional[int] = ...
    def __init__(
        self,
        body: _Body = ...,
        headers: typing.Optional[typing.Any] = ...,
        status: int = ...,
        version: int = ...,
        reason: typing.Optional[str] = ...,
        strict: int = ...,
        preload_content: bool = ...,
        decode_content: bool = ...,
        original_response: typing.Optional['HTTPResponse'] = ...,
        pool: typing.Optional[typing.Any] = ...,
        connection: typing.Optional[_Connection] = ...,
        msg: typing.Optional[typing.Any] = ...,
        retries: typing.Optional[urllib3.util.retry.Retry] = ...,
        enforce_content_length: bool = ...,
        request_method: typing.Optional[str] = ...,
        request_url: typing.Optional[_URL] = ...,
        auto_close: bool = ...,
    ) -> None: ...
    def get_redirect_location(self) -> typing.Union[bool, str]: ...
    def release_conn(self) -> None: ...
    def drain_conn(self) -> None: ...
    @property
    def data(self) -> _Body: ...
    @property
    def connection(self) -> _Connection: ...
    def isclosed(self) -> bool: ...
    def tell(self) -> int: ...
    DECODER_ERROR_CLASSES: typing.Iterable[typing.Type[Exception]] = ...
    def read(
        self,
        amt: typing.Optional[int] = ...,
        decode_content: typing.Optional[bool] = ...,
        cache_content: bool = ...,
    ) -> _Body: ...
    def stream(
        self, amt: int = ..., decode_content: typing.Optional[bool] = ...
    ) -> None: ...
    @classmethod
    def from_httplib(
        ResponseCls: typing.Type['HTTPResponse'],
        r: http.client.HTTPResponse,
        **response_kw: typing.Any,
    ) -> 'HTTPResponse': ...
    def getheaders(self) -> urllib3._collections.HTTPHeaderDict: ...
    def getheader(
        self, name: str, default: typing.Optional[str] = ...
    ) -> typing.Optional[str]: ...
    def info(self) -> urllib3._collections.HTTPHeaderDict: ...
    def close(self) -> None: ...
    @property
    def closed(self) -> bool: ...
    def fileno(self) -> int: ...
    def flush(self) -> None: ...
    def readable(self) -> bool: ...
    def readinto(self, b: _typeshed.WriteableBuffer) -> int: ...
    def supports_chunked_reads(self) -> bool: ...
    def read_chunked(
        self, amt: typing.Optional[int] = ..., decode_content: typing.Optional[bool] = ...
    ) -> None: ...
    def geturl(self) -> _URL: ...
    def __iter__(self) -> typing.Iterator[bytes]: ...
