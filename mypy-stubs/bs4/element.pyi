import re
import typing

import bs4.formatter

DEFAULT_OUTPUT_ENCODING: str
PY3K: bool
nonwhitespace_re: re.Pattern[str]
whitespace_re: re.Pattern[str]
PYTHON_SPECIFIC_ENCODINGS: typing.Set[str]

class NamespacedAttribute(str):
    def __new__(
        cls: typing.Type['NamespacedAttribute'],
        prefix: typing.Optional[str],
        name: typing.Optional[str] = ...,
        namespace: typing.Optional[str] = ...,
    ) -> 'NamespacedAttribute': ...

class AttributeValueWithCharsetSubstitution(str): ...

class PageElement:
    parent: typing.Optional['PageElement'] = ...
    previous_element: typing.Optional['PageElement'] = ...
    next_element: typing.Optional['PageElement'] = ...
    next_sibling: typing.Optional['PageElement'] = ...
    previous_sibling: typing.Optional['PageElement'] = ...
    def setup(
        self,
        parent: typing.Optional['PageElement'] = ...,
        previous_element: typing.Optional['PageElement'] = ...,
        next_element: typing.Optional['PageElement'] = ...,
        previous_sibling: typing.Optional['PageElement'] = ...,
        next_sibling: typing.Optional['PageElement'] = ...,
    ) -> None: ...
    def format_string(
        self, s: str, formatter: typing.Union[str, bs4.formatter.Formatter]
    ) -> str: ...
    def formatter_for_name(
        self, formatter: typing.Union[str, bs4.formatter.Formatter]
    ) -> bs4.formatter.Formatter: ...
    nextSibling: typing.Optional['PageElement'] = ...
    previousSibling: typing.Optional['PageElement'] = ...
    def replace_with(self, replace_with: 'PageElement') -> 'PageElement': ...
    def replaceWith(self, replace_with: 'PageElement') -> 'PageElement': ...
    def unwrap(self) -> 'PageElement': ...
    def replace_with_children(self) -> 'PageElement': ...
    def replaceWithChildren(self) -> 'PageElement': ...
    def wrap(self, wrap_inside: 'PageElement') -> 'PageElement': ...
    def extract(self, _self_index: typing.Optional[int] = ...) -> 'PageElement': ...
    def insert(self, position: int, new_child: 'PageElement') -> None: ...
    def append(self, tag: 'PageElement') -> None: ...
    def extend(self, tags: typing.Iterable['PageElement']) -> None: ...
    def insert_before(self, *args: 'PageElement') -> None: ...
    def insert_after(self, *args: 'PageElement') -> None: ...
    def find_next(
        self,
        name: typing.Optional[typing.Any] = ...,
        attrs: typing.Any = ...,
        text: typing.Optional[typing.Any] = ...,
        **kwargs: typing.Any,
    ): ...
    findNext: typing.Any = ...
    def find_all_next(
        self,
        name: typing.Optional[typing.Any] = ...,
        attrs: typing.Any = ...,
        text: typing.Optional[typing.Any] = ...,
        limit: typing.Optional[typing.Any] = ...,
        **kwargs: typing.Any,
    ): ...
    findAllNext: typing.Any = ...
    def find_next_sibling(
        self,
        name: typing.Optional[typing.Any] = ...,
        attrs: typing.Any = ...,
        text: typing.Optional[typing.Any] = ...,
        **kwargs: typing.Any,
    ): ...
    findNextSibling: typing.Any = ...
    def find_next_siblings(
        self,
        name: typing.Optional[typing.Any] = ...,
        attrs: typing.Any = ...,
        text: typing.Optional[typing.Any] = ...,
        limit: typing.Optional[typing.Any] = ...,
        **kwargs: typing.Any,
    ): ...
    findNextSiblings: typing.Any = ...
    fetchNextSiblings: typing.Any = ...
    def find_previous(
        self,
        name: typing.Optional[typing.Any] = ...,
        attrs: typing.Any = ...,
        text: typing.Optional[typing.Any] = ...,
        **kwargs: typing.Any,
    ): ...
    findPrevious: typing.Any = ...
    def find_all_previous(
        self,
        name: typing.Optional[typing.Any] = ...,
        attrs: typing.Any = ...,
        text: typing.Optional[typing.Any] = ...,
        limit: typing.Optional[typing.Any] = ...,
        **kwargs: typing.Any,
    ): ...
    findAllPrevious: typing.Any = ...
    fetchPrevious: typing.Any = ...
    def find_previous_sibling(
        self,
        name: typing.Optional[typing.Any] = ...,
        attrs: typing.Any = ...,
        text: typing.Optional[typing.Any] = ...,
        **kwargs: typing.Any,
    ): ...
    findPreviousSibling: typing.Any = ...
    def find_previous_siblings(
        self,
        name: typing.Optional[typing.Any] = ...,
        attrs: typing.Any = ...,
        text: typing.Optional[typing.Any] = ...,
        limit: typing.Optional[typing.Any] = ...,
        **kwargs: typing.Any,
    ): ...
    findPreviousSiblings: typing.Any = ...
    fetchPreviousSiblings: typing.Any = ...
    def find_parent(
        self,
        name: typing.Optional[typing.Any] = ...,
        attrs: typing.Any = ...,
        **kwargs: typing.Any,
    ): ...
    findParent: typing.Any = ...
    def find_parents(
        self,
        name: typing.Optional[typing.Any] = ...,
        attrs: typing.Any = ...,
        limit: typing.Optional[typing.Any] = ...,
        **kwargs: typing.Any,
    ): ...
    findParents: typing.Any = ...
    fetchParents: typing.Any = ...
    @property
    def next(self): ...
    @property
    def previous(self): ...
    @property
    def next_elements(self) -> None: ...
    @property
    def next_siblings(self) -> None: ...
    @property
    def previous_elements(self) -> None: ...
    @property
    def previous_siblings(self) -> None: ...
    @property
    def parents(self) -> None: ...
    @property
    def decomposed(self): ...
    def nextGenerator(self): ...
    def nextSiblingGenerator(self): ...
    def previousGenerator(self): ...
    def previousSiblingGenerator(self): ...
    def parentGenerator(self): ...

class NavigableString(str, PageElement):
    PREFIX: str = ...
    SUFFIX: str = ...
    known_xml: typing.Any = ...
    def __new__(cls, value: typing.Any): ...
    def __copy__(self): ...
    def __getnewargs__(self): ...
    def __getattr__(self, attr: typing.Any): ...
    def output_ready(self, formatter: str = ...): ...
    @property
    def name(self) -> None: ...
    @name.setter
    def name(self, name: typing.Any) -> None: ...

class PreformattedString(NavigableString):
    PREFIX: str = ...
    SUFFIX: str = ...
    def output_ready(self, formatter: typing.Optional[typing.Any] = ...): ...

class CData(PreformattedString):
    PREFIX: str = ...
    SUFFIX: str = ...

class ProcessingInstruction(PreformattedString):
    PREFIX: str = ...
    SUFFIX: str = ...

class XMLProcessingInstruction(ProcessingInstruction):
    PREFIX: str = ...
    SUFFIX: str = ...

class Comment(PreformattedString):
    PREFIX: str = ...
    SUFFIX: str = ...

class Declaration(PreformattedString):
    PREFIX: str = ...
    SUFFIX: str = ...

class Doctype(PreformattedString):
    @classmethod
    def for_name_and_ids(
        cls, name: typing.Any, pub_id: typing.Any, system_id: typing.Any
    ): ...
    PREFIX: str = ...
    SUFFIX: str = ...

class Stylesheet(NavigableString): ...
class Script(NavigableString): ...
class TemplateString(NavigableString): ...

class Tag(PageElement):
    parser_class: typing.Any = ...
    name: typing.Any = ...
    namespace: typing.Any = ...
    prefix: typing.Any = ...
    sourceline: typing.Any = ...
    sourcepos: typing.Any = ...
    known_xml: typing.Any = ...
    attrs: typing.Any = ...
    contents: typing.Any = ...
    hidden: typing.Union[bool, int] = ...
    can_be_empty_element: typing.Any = ...
    cdata_list_attributes: typing.Any = ...
    preserve_whitespace_tags: typing.Any = ...
    def __init__(
        self,
        parser: typing.Optional[typing.Any] = ...,
        builder: typing.Optional[typing.Any] = ...,
        name: typing.Optional[typing.Any] = ...,
        namespace: typing.Optional[typing.Any] = ...,
        prefix: typing.Optional[typing.Any] = ...,
        attrs: typing.Optional[typing.Any] = ...,
        parent: typing.Optional[typing.Any] = ...,
        previous: typing.Optional[typing.Any] = ...,
        is_xml: typing.Optional[typing.Any] = ...,
        sourceline: typing.Optional[typing.Any] = ...,
        sourcepos: typing.Optional[typing.Any] = ...,
        can_be_empty_element: typing.Optional[typing.Any] = ...,
        cdata_list_attributes: typing.Optional[typing.Any] = ...,
        preserve_whitespace_tags: typing.Optional[typing.Any] = ...,
    ) -> None: ...
    parserClass: typing.Any = ...
    def __copy__(self): ...
    @property
    def is_empty_element(self): ...
    isSelfClosing: typing.Any = ...
    @property
    def string(self): ...
    @string.setter
    def string(self, string: typing.Any) -> None: ...
    strings: typing.Any = ...
    @property
    def stripped_strings(self) -> None: ...
    def get_text(self, separator: str = ..., strip: bool = ..., types: typing.Any = ...): ...
    getText: typing.Any = ...
    text: typing.Any = ...
    def decompose(self) -> None: ...
    def clear(self, decompose: bool = ...) -> None: ...
    def smooth(self) -> None: ...
    def index(self, element: typing.Any): ...
    def get(self, key: typing.Any, default: typing.Optional[typing.Any] = ...): ...
    def get_attribute_list(
        self, key: typing.Any, default: typing.Optional[typing.Any] = ...
    ): ...
    def has_attr(self, key: typing.Any): ...
    def __hash__(self) -> typing.Any: ...
    def __getitem__(self, key: typing.Any): ...
    def __iter__(self) -> typing.Any: ...
    def __len__(self): ...
    def __contains__(self, x: typing.Any): ...
    def __bool__(self): ...
    def __setitem__(self, key: typing.Any, value: typing.Any) -> None: ...
    def __delitem__(self, key: typing.Any) -> None: ...
    def __call__(self, *args: typing.Any, **kwargs: typing.Any): ...
    def __getattr__(self, tag: typing.Any): ...
    def __eq__(self, other: typing.Any) -> typing.Any: ...
    def __ne__(self, other: typing.Any) -> typing.Any: ...
    def __unicode__(self): ...
    def encode(
        self,
        encoding: typing.Any = ...,
        indent_level: typing.Optional[typing.Any] = ...,
        formatter: str = ...,
        errors: str = ...,
    ): ...
    def decode(
        self,
        pretty_print: bool = ...,
        indent_level: typing.Optional[typing.Any] = ...,
        eventual_encoding: typing.Any = ...,
        formatter: str = ...,
    ): ...
    def prettify(
        self, encoding: typing.Optional[typing.Any] = ..., formatter: str = ...
    ): ...
    def decode_contents(
        self,
        indent_level: typing.Optional[typing.Any] = ...,
        eventual_encoding: typing.Any = ...,
        formatter: str = ...,
    ): ...
    def encode_contents(
        self,
        indent_level: typing.Optional[typing.Any] = ...,
        encoding: typing.Any = ...,
        formatter: str = ...,
    ): ...
    def renderContents(
        self,
        encoding: typing.Any = ...,
        prettyPrint: bool = ...,
        indentLevel: int = ...,
    ): ...
    def find(
        self,
        name: typing.Optional[typing.Any] = ...,
        attrs: typing.Any = ...,
        recursive: bool = ...,
        text: typing.Optional[typing.Any] = ...,
        **kwargs: typing.Any,
    ): ...
    findChild: typing.Any = ...
    def find_all(
        self,
        name: typing.Optional[typing.Any] = ...,
        attrs: typing.Any = ...,
        recursive: bool = ...,
        text: typing.Optional[typing.Any] = ...,
        limit: typing.Optional[typing.Any] = ...,
        **kwargs: typing.Any,
    ): ...
    findAll: typing.Any = ...
    findChildren: typing.Any = ...
    @property
    def children(self): ...
    @property
    def descendants(self) -> None: ...
    def select_one(
        self,
        selector: typing.Any,
        namespaces: typing.Optional[typing.Any] = ...,
        **kwargs: typing.Any,
    ): ...
    def select(
        self,
        selector: typing.Any,
        namespaces: typing.Optional[typing.Any] = ...,
        limit: typing.Optional[typing.Any] = ...,
        **kwargs: typing.Any,
    ): ...
    def childGenerator(self): ...
    def recursiveChildGenerator(self): ...
    def has_key(self, key: typing.Any): ...

class SoupStrainer:
    name: typing.Any = ...
    attrs: typing.Any = ...
    text: typing.Any = ...
    def __init__(
        self,
        name: typing.Optional[typing.Any] = ...,
        attrs: typing.Any = ...,
        text: typing.Optional[typing.Any] = ...,
        **kwargs: typing.Any,
    ) -> None: ...
    def search_tag(
        self, markup_name: typing.Optional[typing.Any] = ..., markup_attrs: typing.Any = ...
    ): ...
    searchTag: typing.Any = ...
    def search(self, markup: typing.Any): ...

class ResultSet(list):
    source: typing.Any = ...
    def __init__(self, source: typing.Any, result: typing.Any = ...) -> None: ...
    def __getattr__(self, key: typing.Any) -> None: ...
